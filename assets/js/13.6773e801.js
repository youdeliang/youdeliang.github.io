(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{396:function(e,n,t){"use strict";t.r(n);var r=t(1),s=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("本篇博客主要是对 Javcscript 异步编程 Promise 的学习理解\n")]),e._v(" "),t("h2",{attrs:{id:"基本概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[e._v("#")]),e._v(" 基本概念")]),e._v(" "),t("p",[t("strong",[e._v("MDN 对 Promise 的定义：")])]),e._v(" "),t("blockquote",[t("p",[e._v("Promise 是一个对象，它代表了一个异步操作的最终完成或者失败。")])]),e._v(" "),t("p",[e._v("Promise 解决的主要是异步编码风格的问题，即解决回调地狱的问题。在开发一些稍复杂点项目时，你会发现，如果嵌套了太多的回调函数就很容易使得自己陷入了回调地狱，不能自拔。你可以参考下面这段让人凌乱的代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("XFetch(makeRequest('https://xxx'),\n      function resolve(response) {\n          console.log(response)\n          XFetch(makeRequest('https://xxx'),\n              function resolve(response) {\n                  console.log(response)\n                  XFetch(makeRequest('https://xxx')\n                      function resolve(response) {\n                          console.log(response)\n                      }, function reject(e) {\n                          console.log(e)\n                      })\n              }, function reject(e) {\n                  console.log(e)\n              })\n      }, function reject(e) {\n          console.log(e)\n      })\n")])])]),t("p",[e._v("这段代码是先请求第一个接口，如果请求成功的话，那么再请求第二个接口，如果再次请求成功的话，就继续请求最后一个接口。也就是说这段代码用了三层嵌套请求，就已经让代码变得混乱不堪，当上述需求中出现第四个请求（甚至更多）仍然依赖上一个请求的时候，代码就会变成一场灾难。")]),e._v(" "),t("p",[e._v("这段代码之所以看上去很乱，归结其原因有两点：")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("第一是嵌套调用")]),e._v("，下面的任务依赖上个任务的请求结果，并"),t("strong",[e._v("在上个任务的回调函数内部执行新的业务逻辑")]),e._v("，这样当嵌套层次多了之后，代码的可读性就变得非常差了。")]),e._v(" "),t("li",[t("strong",[e._v("第二是任务的不确定性")]),e._v("，执行每个任务都有两种可能的结果（成功或者失败），所以体现在代码中就需要对每个任务的执行结果做两次判断，这种对每个任务都要进行一次额外的错误处理的方式，明显增加了代码的混乱程度。")])]),e._v(" "),t("p",[e._v("这时，我们可能会希望：")]),e._v(" "),t("ul",[t("li",[e._v("[x] "),t("strong",[e._v("第一是消灭嵌套调用；")])]),e._v(" "),t("li",[e._v("[x] "),t("strong",[e._v("第二是合并多个任务的错误处理")]),e._v("。")])]),e._v(" "),t("p",[t("strong",[e._v("Promise 主要通过下面两步解决嵌套回调问题的。")])]),e._v(" "),t("ol",[t("li",[t("p",[t("strong",[e._v("首先，Promise 实现了回调函数的延时绑定")]),e._v("。回调函数的延时绑定在代码上体现就是先创建 Promise 对象 promise1，通过 Promise 的构造函数 executor 来执行业务逻辑；创建好 Promise 对象 promise1 之后，再使用 promise1.then 来设置回调函数。")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("其次，需要将回调函数 onResolve 的返回值穿透到最外层")]),e._v("。因为我们会根据 onResolve 函数的传入值来决定创建什么类型的 Promise 任务，创建好的 Promise 对象需要返回到最外层，这样就可以摆脱嵌套循环了。代码如下：")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let promise1 = new Promise((resolve, reject) => {\n    console.log(1)\n    resolve('success')\n})\n\n// then 方法延迟绑定 返回值穿透赋给 p2\nlet p2 = promise1.then(res => {\n    console.log(res)\n    return 2\n})\nsetTimeout(() => {\n   console.log(p2) \n})\n// 输出 1 ,success, 2\n")])])]),t("p",[e._v("Promise 通过回调函数延迟绑定和回调函数返回值穿透的技术，解决了循环嵌套。\n接下来我们再来看看 Promise 是怎么处理异常的：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\nfunction executor(resolve, reject) {\n    let rand = Math.random();\n    console.log(1)\n    console.log(rand)\n    if (rand > 0.5)\n        resolve()\n    else\n        reject()\n}\nvar p0 = new Promise(executor);\n\nvar p1 = p0.then((value) => {\n    console.log("succeed-1")\n    return new Promise(executor)\n})\np1.catch((error) => {\n    console.log("error")\n})\nconsole.log(2)\n')])])]),t("p",[e._v("上面 p0, p1 无论哪个对象报错都可以在最后 catch 里面捕获到。\n之所以可以使用最后一个对象来捕获所有异常，是因为 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被 onReject 函数处理或 catch 语句捕获为止。具备了这样“冒泡”的特性后，就不需要在每个 Promise 对象中单独捕获异常了。")]),e._v(" "),t("h2",{attrs:{id:"原理剖析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原理剖析"}},[e._v("#")]),e._v(" 原理剖析")]),e._v(" "),t("p",[e._v("上面我们了解 Promise 的实现主要是通过延迟回调、返回值穿透以及错误的‘冒泡’捕获。")]),e._v(" "),t("p",[e._v("接下来，我们通过源码实现来更深层次的理解这些技术实现，深入理解 Promise。")]),e._v(" "),t("h3",{attrs:{id:"极简promise雏形"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#极简promise雏形"}},[e._v("#")]),e._v(" 极简Promise雏形")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function Promise(executor) {\n  this.value = null   // 存储 resolved 的值\n  this.reason = null // 存储 rejected 的值\n  this.onFulfilledArray = [] // 可能同时有多个回调，用数组来存储\n  this.onRejectedArray = [] //可能同时有多个回调，用数组来存储\n\n  const resolve = value => {\n    this.value = value\n    this.onFulfilledArray.forEach(func => {\n      func(value)\n    })\n  }\n\n  const reject = reason => {\n    this.reason = reason\n    this.onRejectedArray.forEach(func => {\n      func(reason)\n    })\n  }\n  \n   executor(resolve, reject)\n}\n\nPromise.prototype.then = function(onfulfilled, onrejected) {\n    this.onFulfilledArray.push(onfulfilled)\n    this.onRejectedArray.push(onrejected)\n}\n")])])]),t("p",[e._v("上述代码比较简单，大概的逻辑是这样的：")]),e._v(" "),t("ol",[t("li",[e._v("调用 then 方法，将想要在 Promise 异步操作成功时执行的回调放入 onFulfilledArray 队列里，失败时执行的回调放在 onRejectedArray 队列里。")]),e._v(" "),t("li",[e._v("创建 Promise 实例时传入的函数会被赋予函数类型的参数，即 resolve 和 reject，它们接收一个参数，代表异步操作返回的结果，当一步操作执行成功后，用户会调用 resolve 方法。失败时，会执行 reject 方法。这时候其实真正执行的操作是将队列中的回调一一执行。")])]),e._v(" "),t("h3",{attrs:{id:"加入延迟绑定机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#加入延迟绑定机制"}},[e._v("#")]),e._v(" 加入延迟绑定机制")]),e._v(" "),t("p",[e._v("细心的小伙伴可能会发现，上述的代码还存在一些问题：在 then 回调之前， resolve 和 reject 函数就会执行。因此，需要将 resolve 和 reject 的执行，放到任务队列中。这里姑且先放到 setTimeout 里，保证异步执行（这样的做法并不严谨，为了保证 Promise 属于 microtasks，很多 Promise 的实现库用了 MutationObserver 来模仿 nextTick）")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" const resolve = value => {\n    // setTimeout 模拟异步执行\n    setTimeout(() => { \n      this.value = value\n      this.onFulfilledArray.forEach(func => {\n        func(value)\n      })\n    })\n  }\n\n  const reject = reason => {\n    // setTimeout 模拟异步执行\n    setTimeout(() => { \n      this.reason = reason\n      this.onRejectedArray.forEach(func => {\n        func(reason)\n      })\n    })\n  }\n")])])]),t("h3",{attrs:{id:"加入状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#加入状态"}},[e._v("#")]),e._v(" 加入状态")]),e._v(" "),t("p",[e._v("Promises/A+ 规范中的 Promise States 中明确规定了，pending 可以转化为 fulfilled 或 rejected 并且只能转化一次，也就是说如果 pending 转化到 fulfilled 状态，那么就不能再转化到 rejected。并且 fulfilled 和 rejected 状态只能由 pending 转化而来，两者之间不能互相转换。一图胜千言：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/6/8/17292885fc45811c?w=353&h=260&f=png&s=4035",alt:""}}),e._v("\n改进后的代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function Promise(executor) {\n  this.status = 'pending'\n  this.value = null\n  this.reason = null\n  this.onFulfilledArray = []\n  this.onRejectedArray = []\n\n  const resolve = value => {\n    // setTimeout 模拟异步执行\n    setTimeout(() => { \n      if (this.status === 'pending') {\n        this.value = value\n        this.status = 'fulfilled'\n\n        this.onFulfilledArray.forEach(func => {\n          func(value)\n        })\n      }\n    })\n  }\n\n  const reject = reason => {\n    // setTimeout 模拟异步执行\n    setTimeout(() => { \n      if (this.status === 'pending') {\n        this.reason = reason\n        this.status = 'rejected'\n        \n        this.onRejectedArray.forEach(func => {\n          func(reason)\n        })\n      }\n    })\n  }\n  executor(resolve, reject)\n}\n\nPromise.prototype.then = function(onfulfilled, onrejected) {\n  if (this.status === 'fulfilled') {\n    onfulfilled(this.value)\n  }\n  if (this.status === 'rejected') {\n    onrejected(this.reason)\n  }\n  if (this.status === 'pending') {\n    this.onFulfilledArray.push(onfulfilled)\n    this.onRejectedArray.push(onrejected)\n  }\n}\n")])])]),t("p",[e._v("上述代码的思路是这样的：resolve 和 reject 执行时，会将状态设置为 fulfilled 和 rejected， 在此之后调用 then 添加的新回调，都会立即执行。")]),e._v(" "),t("h3",{attrs:{id:"链式promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链式promise"}},[e._v("#")]),e._v(" 链式Promise")]),e._v(" "),t("p",[e._v("先从下面例题说起：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n      resolve('lucas')\n  }, 2000)\n})\n\npromise.then(data => {\n  console.log(data)\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve(`${data} next then`)\n    }, 4000)\n  })\n})\n.then(data => {\n  console.log(data)\n})\n")])])]),t("p",[e._v("将在 2 秒后输出：lucas，紧接着再过 4 秒后（第 6 秒）输出：lucas next then。")]),e._v(" "),t("p",[e._v("这种场景相信用 过promise 的人都知道会有很多，那么类似这种就是所谓的链式 Promise。")]),e._v(" "),t("p",[e._v("一个 Promise 实例的 then 方法体 onfulfilled 函数和 onrejected 函数中，是支持再次返回一个 Promise 实例的，也支持返回一个非 Promise 实例的普通值；并且返回的这个 Promise 实例或者这个非 Promise 实例的普通值将会传给下一个 then 方法 onfulfilled 函数或者 onrejected 函数中，这样就支持链式调用了。")]),e._v(" "),t("p",[e._v("对 then 方法进行代码改造后：")]),e._v(" "),t("details",[t("summary",[e._v(" 点击展开完整代码 ")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// then 方法中 变量 result 既可以是一个普通值，也可以是一个 Promise 实例，为此我们抽象出 resolvePromise 方法进行统一处理 \n\nconst resolvePromise = (promise2, result, resolve, reject) => {\n  // 当 result 和 promise2 相等时，也就是说 onfulfilled 返回 promise2 时，进行 reject\n  if (result === promise2) {\n    return reject(new TypeError('error due to circular reference'))\n  }\n\n  // 是否已经执行过 onfulfilled 或者 onrejected\n  let consumed = false\n  let thenable\n\n  if (result instanceof Promise) {\n    if (result.status === 'pending') {\n      result.then(function(data) {\n        resolvePromise(promise2, data, resolve, reject)\n      }, reject)\n    } else {\n      result.then(resolve, reject)\n    }\n    return\n  }\n\n  let isComplexResult = target => (typeof target === 'function' || typeof target === 'object') && (target !== null)\n  // 如果返回的是疑似 Promise 类型\n  if (isComplexResult(result)) {\n    try {\n      thenable = result.then\n      // 如果返回的是 Promise 类型，具有 then 方法\n      if (typeof thenable === 'function') {\n        thenable.call(result, function(data) {\n          if (consumed) {\n            return\n          }\n          consumed = true\n\n          return resolvePromise(promise2, data, resolve, reject)\n        }, function(error) {\n          if (consumed) {\n            return\n          }\n          consumed = true\n\n          return reject(error)\n        })\n      }\n      else {\n        return resolve(result)\n      }\n\n    } catch(e) {\n      if (consumed) {\n        return\n      }\n      consumed = true\n      return reject(e)\n    }\n  }\n  else {\n    return resolve(result)\n  }\n}\n\nPromise.prototype.then = function(onfulfilled, onrejected) {\n  onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : data => data\n  onrejected = typeof onrejected === 'function' ? onrejected : error => {throw error}\n\n  // promise2 将作为 then 方法的返回值\n  let promise2\n\n  if (this.status === 'fulfilled') {\n    return promise2 = new Promise((resolve, reject) => {\n      setTimeout(() => {\n        try {\n          // 这个新的 promise2 resolved 的值为 onfulfilled 的执行结果\n          let result = onfulfilled(this.value)\n          resolvePromise(promise2, result, resolve, reject)\n        }\n        catch(e) {\n          reject(e)\n        }\n      })\n    })\n  }\n  if (this.status === 'rejected') {\n    return promise2 = new Promise((resolve, reject) => {\n      setTimeout(() => {\n        try {\n          // 这个新的 promise2 reject 的值为 onrejected 的执行结果\n         let result = onrejected(this.reason)\n         resolvePromise(promise2, result, resolve, reject)\n        }\n        catch(e) {\n          reject(e)\n        }\n      })\n    })\n  }\n  if (this.status === 'pending') {\n    return promise2 = new Promise((resolve, reject) => {\n      this.onFulfilledArray.push(value => {\n        try {\n          let result = onfulfilled(value)\n          resolvePromise(promise2, result, resolve, reject)\n        }\n        catch(e) {\n          return reject(e)\n        }\n      })\n\n      this.onRejectedArray.push(reason => {\n        try {\n          let result = onrejected(reason)\n          resolvePromise(promise2, result, resolve, reject)\n        }\n        catch(e) {\n          return reject(e)\n        }\n      })      \n    })\n  }\n}\n")])])])]),e._v(" "),t("h3",{attrs:{id:"promise-值穿透"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-值穿透"}},[e._v("#")]),e._v(" Promise 值穿透")]),e._v(" "),t("p",[e._v("看下面例子：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n      resolve('lucas')\n  }, 2000)\n})\n\n\npromise.then(null)\n.then(data => {\n  console.log(data)\n})\n")])])]),t("p",[e._v("这段代码将会在 2 秒后输出：lucas。这就是 Promise 穿透现象：")]),e._v(" "),t("p",[e._v("给 .then() 函数传递非函数值作为其参数时，实际上会被解析成 .then(null)，这时候的表现应该是：上一个 promise 对象的结果进行“穿透”，如果在后面链式调用仍存在第二个 .then() 函数时，将会获取被穿透下来的结果。")]),e._v(" "),t("p",[e._v("值穿透代码实现：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Promise.prototype.then = function(onfulfilled = Function.prototype, onrejected = Function.prototype) {\n  // 如果 then 方法接收的不是函数，则默认赋予直接返回其值函数，从而实现穿透\n  onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : data => data\n  onrejected = typeof onrejected === 'function' ? onrejected : error => { throw error }\n\n    // ...\n}\n")])])]),t("h3",{attrs:{id:"异常处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异常处理"}},[e._v("#")]),e._v(" 异常处理")]),e._v(" "),t("p",[e._v("Promise.prototype.catch 可以进行异常捕获，它的典型用法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const promise1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n      reject('lucas error')\n  }, 2000)\n})\n\npromise1.then(data => {\n  console.log(data)\n}).catch(error => {\n  console.log(error)\n})\n")])])]),t("p",[e._v("会在 2 秒后输出：lucas error。")]),e._v(" "),t("p",[e._v("其实在这种场景下，它就相当于：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Promise.prototype.catch = function(catchFunc) {\n  return this.then(null, catchFunc)\n}\n")])])]),t("p",[e._v("因为我们知道 .then() 方法的第二个参数也是进行异常捕获的，通过这个特性，我们比较简单地实现了 Promise.prototype.catch。")]),e._v(" "),t("h3",{attrs:{id:"promise-prototype-resolve-实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-prototype-resolve-实现"}},[e._v("#")]),e._v(" Promise.prototype.resolve 实现")]),e._v(" "),t("p",[e._v("请看实例：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Promise.resolve('data').then(data => {\n  console.log(data)\n})\nconsole.log(1)\n")])])]),t("p",[e._v("先输出 1 再输出 data。")]),e._v(" "),t("p",[e._v("那么实现 Promise.resolve(value) 也很简单：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Promise.resolve = function(value) {\n  return new Promise((resolve, reject) => {\n    resolve(value)\n  })\n}\n")])])]),t("p",[e._v("顺带实现一个 "),t("strong",[e._v("Promise.reject(value)")]),e._v("：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Promise.reject = function(value) {\n  return new Promise((resolve, reject) => {\n    reject(value)\n  })\n}\n")])])]),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("p",[e._v("最后把完整代码贴出：")]),e._v(" "),t("details",[t("summary",[e._v(" 点击展开完整代码 ")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("function Promise(executor) {\n  this.status = 'pending'\n  this.value = null\n  this.reason = null\n  this.onFulfilledArray = []\n  this.onRejectedArray = []\n\n  const resolve = value => {\n    if (value instanceof Promise) {\n      return value.then(resolve, reject)\n    }\n    setTimeout(() => {\n      if (this.status === 'pending') {\n        this.value = value\n        this.status = 'fulfilled'\n\n        this.onFulfilledArray.forEach(func => {\n          func(value)\n        })\n      }\n    })\n  }\n\n  const reject = reason => {\n    setTimeout(() => {\n      if (this.status === 'pending') {\n        this.reason = reason\n        this.status = 'rejected'\n\n        this.onRejectedArray.forEach(func => {\n          func(reason)\n        })\n      }\n    })\n  }\n\n\n    try {\n        executor(resolve, reject)\n    } catch(e) {\n        reject(e)\n    }\n}\n\nconst resolvePromise = (promise2, result, resolve, reject) => {\n  // 当 result 和 promise2 相等时，也就是说 onfulfilled 返回 promise2 时，进行 reject\n  if (result === promise2) {\n    return reject(new TypeError('error due to circular reference'))\n  }\n\n  // 是否已经执行过 onfulfilled 或者 onrejected\n  let consumed = false\n  let thenable\n\n  if (result instanceof Promise) {\n    if (result.status === 'pending') {\n      result.then(function(data) {\n        resolvePromise(promise2, data, resolve, reject)\n      }, reject)\n    } else {\n      result.then(resolve, reject)\n    }\n    return\n  }\n\n  let isComplexResult = target => (typeof target === 'function' || typeof target === 'object') && (target !== null)\n  // 如果返回的是疑似 Promise 类型\n  if (isComplexResult(result)) {\n    try {\n      thenable = result.then\n      // 如果返回的是 Promise 类型，具有 then 方法\n      if (typeof thenable === 'function') {\n        thenable.call(result, function(data) {\n          if (consumed) {\n            return\n          }\n          consumed = true\n\n          return resolvePromise(promise2, data, resolve, reject)\n        }, function(error) {\n          if (consumed) {\n            return\n          }\n          consumed = true\n\n          return reject(error)\n        })\n      }\n      else {\n        return resolve(result)\n      }\n\n    } catch(e) {\n      if (consumed) {\n        return\n      }\n      consumed = true\n      return reject(e)\n    }\n  }\n  else {\n    return resolve(result)\n  }\n}\n\nPromise.prototype.then = function(onfulfilled, onrejected) {\n  onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : data => data\n  onrejected = typeof onrejected === 'function' ? onrejected : error => {throw error}\n\n  // promise2 将作为 then 方法的返回值\n  let promise2\n\n  if (this.status === 'fulfilled') {\n    return promise2 = new Promise((resolve, reject) => {\n      setTimeout(() => {\n        try {\n          // 这个新的 promise2 resolved 的值为 onfulfilled 的执行结果\n          let result = onfulfilled(this.value)\n          resolvePromise(promise2, result, resolve, reject)\n        }\n        catch(e) {\n          reject(e)\n        }\n      })\n    })\n  }\n  if (this.status === 'rejected') {\n    return promise2 = new Promise((resolve, reject) => {\n      setTimeout(() => {\n        try {\n          // 这个新的 promise2 reject 的值为 onrejected 的执行结果\n         let result = onrejected(this.reason)\n         resolvePromise(promise2, result, resolve, reject)\n        }\n        catch(e) {\n          reject(e)\n        }\n      })\n    })\n  }\n  if (this.status === 'pending') {\n    return promise2 = new Promise((resolve, reject) => {\n      this.onFulfilledArray.push(value => {\n        try {\n          let result = onfulfilled(value)\n          resolvePromise(promise2, result, resolve, reject)\n        }\n        catch(e) {\n          return reject(e)\n        }\n      })\n\n      this.onRejectedArray.push(reason => {\n        try {\n          let result = onrejected(reason)\n          resolvePromise(promise2, result, resolve, reject)\n        }\n        catch(e) {\n          return reject(e)\n        }\n      })      \n    })\n  }\n}\n\nPromise.prototype.catch = function(catchFunc) {\n  return this.then(null, catchFunc)\n}\n\nPromise.resolve = function(value) {\n  return new Promise((resolve, reject) => {\n    resolve(value)\n  })\n}\n\nPromise.reject = function(value) {\n  return new Promise((resolve, reject) => {\n    reject(value)\n  })\n}\n")])])])]),e._v(" "),t("h2",{attrs:{id:"参考文献"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[e._v("#")]),e._v(" 参考文献")]),e._v(" "),t("ul",[t("li",[e._v("[x] "),t("a",{attrs:{href:"https://mengera88.github.io/2017/05/18/Promise%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/",target:"_blank",rel:"noopener noreferrer"}},[e._v("30分钟，让你彻底明白Promise原理"),t("OutboundLink")],1)]),e._v(" "),t("li",[e._v("[x] "),t("a",{attrs:{href:"https://time.geekbang.org/column/article/136895",target:"_blank",rel:"noopener noreferrer"}},[e._v("浏览器工作原理与实践"),t("OutboundLink")],1)]),e._v(" "),t("li",[e._v("[x] "),t("a",{attrs:{href:"https://gitbook.cn/gitchat/column/5c91c813968b1d64b1e08fde/topic/5cbbe946bbbba80861a35bfc",target:"_blank",rel:"noopener noreferrer"}},[e._v("前端开发核心知识进阶"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);n.default=s.exports}}]);